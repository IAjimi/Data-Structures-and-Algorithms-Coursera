def returnChange(money, coins):
	change = [m for m in range(money + 1)] # most coins that could be used to make change

	for m in range(money + 1):
		for c in coins:
			if c <= m: # coin can be used to make change
				numCoins = change[m - c] + 1 # one more coin than optimal prev choice

				if numCoins <= change[m]: # if improves on current option
					change[m] = numCoins # is optimal choice

	return change[-1]


-- x * 2, x * 3, x + 1
given n, find minimum number of operations to get there from n

5
3 operations, 1 2 4 5

ops = [1, 2, 3]

--> change = [1, 2, 3, 4, 5]
--> 

	1 + 1 = 2 < 5 OK
	1 * 2 = 2 < 5 OK
	1 * 3 = 3 < 5 OK

	2 + 1 = 3 < 5 OK
	2 * 2 = 4 < 5 OK
	2 * 3 = 6 > 5 STOP

	3 + 1 = 4 < 5 OK
	3 * 2 = 6 > 5 STOP

	4 + 1 = 5 = 5 OK
	4 * 2 = 8 > 5 STOP

def minimumOperations(num, coins):
	ops = [m for m in range(num)] # most operations that could be used
	chain = {}
    
	for m in range(1, num + 1):
		print(chain)       
		for c in coins:
			if c == 1:
				numOps = ops[m - 1] + 1
				prev = ops[m - 1]
				val = m + 1
			elif c == 2:
				numOps = ops[m // 2] + 1
				prev = ops[m // 2]
				val = m * 2
			elif c == 3:
				numOps = ops[m // 3] + 1
				prev = ops[m // 3]
				val = m * 3
			else:
				return 0

			if (val <= num): # if within bounds
				if (numOps <= ops[val - 1]): # and improves on current option
					ops[val - 1] = numOps # is optimal choice	    
					chain[val] = c
        
    # Get Steps from Chain
	steps = unravelChain(num, chain)

	return ops[-1], steps

# (ops, chain) = ([0, 1, 1, 2, 3], {2: 2, 3: 3, 4: 1, 5: 1})


def unravelChain(num, chain):
	steps = []
	_next = num

	while _next in chain.keys():
		steps.append(_next)
		c = chain[_next] # get operation that was used
		_next = _next - c # move to next value

	steps.append(1)
	steps.reverse()

	return steps


############

def EditDistance(A, B):
	n, m = len(A) + 1, len(B) + 1

	D = {}
	for i in range(n): D[(i, 0)] = i
	for j in range(m): D[(0, j)] = j

	for j in range(1, m):
		for i in range(1, n):
			insertion = D[(i, j - 1)] + 1
			deletion = D[(i - 1, j)] + 1
			match = D[(i - 1, j - 1)]
			mismatch = D[(i - 1, j - 1)] + 1
            
			if A[i - 1] == B[j - 1]:
				D[(i, j)] = min(insertion, deletion, match)
			else:
				D[(i, j)] = min(insertion, deletion, mismatch)

	return D[(n - 1, m - 1)]

def OutputAlignment(i, j):
	if i == 0 and j == 0:
		return
	if i > 0 and D[(i, j)] == D[(i - 1, j)] + 1:
		OutputAlignment(i - 1, j)
		print(str(A[i]) + '\n' + '-')
	elif j > 0 and D[(i, j)] == D[(i, j - 1)] + 1:
		OutputAlignment(i, j - 1)
		print('-' + '\n' + str(B[j]))
	else:
		OutputAlignment(i - 1, j - 1)
		print(str(A[i]) + '\n' + str(B[j]))